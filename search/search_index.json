{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Fast Causal SHAP","text":"<p>Fast Causal SHAP is a Python package designed for efficient and interpretable SHAP value computation in causal inference tasks. It integrates seamlessly with various causal inference frameworks and enables feature attribution with awareness of causal dependencies.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fast computation of SHAP values for causal models</li> <li>Support for multiple causal inference frameworks</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install the stable version via PyPI:</p> <pre><code>pip install fast-causal-shap\n</code></pre> <p>For Development <pre><code>  Clone and install in editable mode with development dependencies:\n  git clone https://github.com/woonyee28/CausalSHAP.git\n  cd CausalSHAP\n  pip install -e \".[dev]\"\n  pre-commit install\n</code></pre></p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import json\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestRegressor\nfrom fast_causal_shap import FastCausalSHAP\n\n# Load your data\ndata = pd.DataFrame({\n    'X1': [1, 2, 3, 4, 5],\n    'X2': [2, 4, 6, 8, 10],\n    'Y': [3, 6, 9, 12, 15]\n})\n\n# Train a model\nmodel = RandomForestRegressor()\nX = data[['X1', 'X2']]\ny = data['Y']\nmodel.fit(X, y)\n\n# Causal effects JSON file\n# This defines the causal relationships: X1 -&gt; Y and X2 -&gt; Y\ncausal_effects = [\n    {\"Pair\": \"X1-&gt;Y\", \"Mean_Causal_Effect\": 0.8},\n    {\"Pair\": \"X2-&gt;Y\", \"Mean_Causal_Effect\": 0.5}\n]\nwith open('causal_effects.json', 'w') as f:\n    json.dump(causal_effects, f)\n\n# Initialize FastCausalSHAP\nshap_explainer = FastCausalSHAP(data, model, target_variable='Y')\n\n# Load causal graph\nshap_explainer.load_causal_strengths('causal_effects.json')\n\n# Compute SHAP values for a single instance\nshap_values = shap_explainer.compute_modified_shap_proba(data.iloc[0])\nprint(shap_values)\n</code></pre>"},{"location":"#working-with-different-causal-inference-algorithms","title":"Working with Different Causal Inference Algorithms","text":"<p>Fast Causal SHAP supports integration with structural algorithms such as: 1. Peter-Clarke (PC) Algorithm 2. IDA Algorithm 3. Fast Causal Inference (FCI) Algorithm You can find example R code for these integrations here: FastCausalSHAP R code examples</p> <p>Generate your causal graph using your preferred algorithm, then export to JSON format.</p> <p>Format of the Causal_Effect.json: <pre><code>[\n  {\n    \"Pair\": \"Bacteroidia-&gt;Clostridia\",\n    \"Mean_Causal_Effect\": 0.71292\n  },\n  {\n    \"Pair\": \"Clostridia-&gt;Alphaproteobacteria\",\n    \"Mean_Causal_Effect\": 0.37652\n  }, ......\n]\n</code></pre></p>"},{"location":"#development-and-contributions","title":"Development and Contributions","text":"<p>Setup Development Environment <pre><code>  # Clone repository\n  git clone https://github.com/woonyee28/CausalSHAP.git\n  cd CausalSHAP\n\n  # Install with dev dependencies\n  pip install -e \".[dev]\"\n\n  # Install pre-commit hooks\n  pre-commit install\n\n  # Running Tests\n  pre-commit run --all-files\n\n  # Run all tests\n  pytest\n\n  # Run with coverage\n  pytest --cov=fast_causal_shap --cov-report=html\n\n  # View coverage report\n  open htmlcov/index.html\n</code></pre> Code Quality</p> <p>This project uses automated code quality tools:   - Black: Code formatting   - isort: Import sorting   - Flake8: Linting   - mypy: Type checking</p>"},{"location":"#troubleshooting-faq","title":"Troubleshooting / FAQ","text":"<p>Q: I get \"Must call load_causal_strengths() before computing SHAP values\" - A: You need to load a causal graph before computing SHAP values. Call <code>load_causal_strengths()</code> first.</p> <p>Q: \"model must have 'feature_names_in_' attribute\" - A: Ensure your model has been fitted before passing it to FastCausalSHAP.</p> <p>Q: JSON file validation errors - A: Check that your JSON file follows the correct format (see Causal Graph Format section).</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome through pull request!</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use Fast Causal SHAP in your research, please cite: <pre><code>@inproceedings{ng2025causal,\n  title={Causal SHAP: Feature Attribution with Dependency Awareness through Causal Discovery},\n  author={Ng, Woon Yee and Wang, Li Rong and Liu, Siyuan and Fan, Xiuyi},\n  booktitle={Proceedings of the International Joint Conference on Neural Networks (IJCNN)},\n  year={2025},\n  organization={IEEE}\n}\n</code></pre></p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP","title":"FastCausalSHAP","text":"<pre><code>FastCausalSHAP(data: DataFrame, model: Any, target_variable: str)\n</code></pre> <p>Initialize FastCausalSHAP with data, model, and target variable.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The dataset containing features and target variable. Must not be empty.</p> required <code>model</code> <code>Any</code> <p>A fitted sklearn model with predict() method and feature_names_in_ attribute Can be a classifier or regressor.</p> required <code>target_variable</code> <code>str</code> <p>The name of the target variable column in the data. Must exist in data.columns.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If data is not a pandas DataFrame.</p> <code>ValueError</code> <p>If data is empty or target_variable not in data columns.</p> <code>AttributeError</code> <p>If model doesn't have required methods/attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from sklearn.ensemble import RandomForestRegressor\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = pd.DataFrame({'X1': [1, 2, 3], 'X2': [4, 5, 6], 'Y': [7, 8, 9]})\n&gt;&gt;&gt; model = RandomForestRegressor()\n&gt;&gt;&gt; model.fit(data[['X1', 'X2']], data['Y'])\n&gt;&gt;&gt;\n&gt;&gt;&gt; shap = FastCausalSHAP(data, model, 'Y')\n</code></pre> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def __init__(self, data: pd.DataFrame, model: Any, target_variable: str) -&gt; None:\n    \"\"\"\n    Initialize FastCausalSHAP with data, model, and target variable.\n\n    Parameters\n    ----------\n    data : pd.DataFrame\n        The dataset containing features and target variable.\n        Must not be empty.\n    model : Any\n        A fitted sklearn model with predict() method and feature_names_in_ attribute\n        Can be a classifier or regressor.\n    target_variable : str\n        The name of the target variable column in the data.\n        Must exist in data.columns.\n\n    Raises\n    ------\n    TypeError\n        If data is not a pandas DataFrame.\n    ValueError\n        If data is empty or target_variable not in data columns.\n    AttributeError\n        If model doesn't have required methods/attributes.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from sklearn.ensemble import RandomForestRegressor\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = pd.DataFrame({'X1': [1, 2, 3], 'X2': [4, 5, 6], 'Y': [7, 8, 9]})\n    &gt;&gt;&gt; model = RandomForestRegressor()\n    &gt;&gt;&gt; model.fit(data[['X1', 'X2']], data['Y'])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; shap = FastCausalSHAP(data, model, 'Y')\n    \"\"\"\n    if not isinstance(data, pd.DataFrame):\n        raise TypeError(\"data must be a pandas DataFrame\")\n\n    if data.empty:\n        raise ValueError(\"data must not be empty\")\n\n    if target_variable not in data.columns:\n        raise ValueError(\n            f\"target_variable '{target_variable}' not found in data columns. \"\n            f\"Available columns: {list(data.columns)}\"\n        )\n\n    if not hasattr(model, \"predict\"):\n        raise AttributeError(\"model must have a predict method\")\n\n    if not hasattr(model, \"feature_names_in_\"):\n        raise AttributeError(\n            \"model must have 'feature_names_in_' attribute. \"\n            \"Ensure the model has been fitted before passing it.\"\n        )\n\n    self.data: pd.DataFrame = data\n    self.model: Any = model\n    self.gamma: Optional[Dict[str, float]] = None\n    self.target_variable: str = target_variable\n    self.ida_graph: Optional[nx.DiGraph] = None\n    self.regression_models: Dict[Tuple[str, Tuple[str, ...]], Tuple[Any, float]] = (\n        {}\n    )\n    self.feature_depths: Dict[str, int] = {}\n    self.path_cache: Dict[Any, float] = {}\n    self.causal_paths: Dict[str, List[List[str]]] = {}\n</code></pre>"},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP.compute_modified_shap_proba","title":"compute_modified_shap_proba","text":"<pre><code>compute_modified_shap_proba(x: Series, is_classifier: bool = False) -&gt; Dict[str, float]\n</code></pre> <p>TreeSHAP-inspired computation using causal paths and dynamic programming.</p> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def compute_modified_shap_proba(\n    self, x: pd.Series, is_classifier: bool = False\n) -&gt; Dict[str, float]:\n    \"\"\"TreeSHAP-inspired computation using causal paths and dynamic programming.\"\"\"\n    if self.gamma is None:\n        raise ValueError(\n            \"Must call load_causal_strengths before computing SHAP values\"\n        )\n    if not isinstance(x, pd.Series):\n        raise TypeError(f\"x must be a pandas Series, got {type(x).__name__}\")\n\n    # validate x contains required features\n    required_features = self.model.feature_names_in_\n    missing_features = set(required_features) - set(x.index)\n    if missing_features:\n        raise ValueError(\n            f\"x is missing required features: {missing_features}. \"\n            f\"Required features: {list(required_features)}\"\n        )\n\n    features = [col for col in self.data.columns if col != self.target_variable]\n    phi_causal = {feature: 0.0 for feature in features}\n\n    data_without_target = self.data.drop(columns=[self.target_variable])\n    if is_classifier:\n        E_fX = self.model.predict_proba(data_without_target)[:, 1].mean()\n    else:\n        E_fX = self.model.predict(data_without_target).mean()\n\n    x_ordered = x[self.model.feature_names_in_]\n    if is_classifier:\n        f_x = self.model.predict_proba(x_ordered.to_frame().T)[0][1]\n    else:\n        f_x = self.model.predict(x_ordered.to_frame().T)[0]\n\n    sorted_features = sorted(features, key=lambda f: self.feature_depths.get(f, 0))\n    max_path_length = max(self.feature_depths.values(), default=0)\n    shapley_weights = {}\n    for m in range(max_path_length + 1):\n        for d in range(m + 1, max_path_length + 1):\n            shapley_weights[(m, d)] = (\n                factorial(m) * factorial(d - m - 1)\n            ) / factorial(d)\n\n    # Track contributions using dynamic programming (EXTEND-like logic in TreeSHAP)\n    # m_values will accumulate contributions from subsets (use combinatorial logic)\n    # Essentially, values in m_values[k] represent how many ways there are\n    # to select k nodes from the path seen so far.\n    for feature in sorted_features:\n        if feature not in self.causal_paths:\n            continue\n        for path in self.causal_paths[feature]:\n            path_features = [n for n in path if n != self.target_variable]\n            d = len(path_features)\n            m_values = defaultdict(float)\n            m_values[0] = 1.0\n\n            for node in path_features:\n                if node == feature:\n                    continue\n\n                new_m_values: defaultdict[int, float] = defaultdict(float)\n                for m, val in m_values.items():\n                    new_m_values[m + 1] += val\n                    new_m_values[m] += val\n                m_values = new_m_values\n\n            for m in m_values:\n                weight = shapley_weights.get((m, d), 0) * self.gamma.get(feature, 0)\n                delta_v = self._compute_path_delta_v(\n                    feature, path, m, x, is_classifier\n                )\n                phi_causal[feature] += weight * delta_v\n\n    sum_phi = sum(phi_causal.values())\n    if sum_phi != 0:\n        scaling_factor = (f_x - E_fX) / sum_phi\n        phi_causal = {k: v * scaling_factor for k, v in phi_causal.items()}\n\n    return phi_causal\n</code></pre>"},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP.compute_v_do","title":"compute_v_do","text":"<pre><code>compute_v_do(S: List[str], x_S: Dict[str, float], is_classifier: bool = False) -&gt; float\n</code></pre> <p>Compute interventional expectations with caching.</p> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def compute_v_do(\n    self, S: List[str], x_S: Dict[str, float], is_classifier: bool = False\n) -&gt; float:\n    \"\"\"Compute interventional expectations with caching.\"\"\"\n    cache_key = (\n        frozenset(S),\n        tuple(sorted(x_S.items())) if len(x_S) &gt; 0 else tuple(),\n    )\n\n    if cache_key in self.path_cache:\n        return self.path_cache[cache_key]\n\n    variables_order = self.get_topological_order(S)\n\n    sample = {}\n    for feature in S:\n        sample[feature] = x_S[feature]\n    for feature in variables_order:\n        if feature in S or feature == self.target_variable:\n            continue\n        parents = self.get_parents(feature)\n        parent_values = {\n            p: x_S[p] if p in S else sample[p]\n            for p in parents\n            if p != self.target_variable\n        }\n        if not parent_values:\n            sample[feature] = self.sample_marginal(feature)\n        else:\n            sample[feature] = self.sample_conditional(feature, parent_values)\n\n    intervened_data = pd.DataFrame([sample])\n    intervened_data = intervened_data[self.model.feature_names_in_]\n    if is_classifier:\n        probas = self.model.predict_proba(intervened_data)[:, 1]\n    else:\n        probas = self.model.predict(intervened_data)\n\n    result = float(np.mean(probas))\n    self.path_cache[cache_key] = result\n    return result\n</code></pre>"},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP.get_parents","title":"get_parents","text":"<pre><code>get_parents(feature: str) -&gt; List[str]\n</code></pre> <p>Returns the parent features for a given feature in the causal graph.</p> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def get_parents(self, feature: str) -&gt; List[str]:\n    \"\"\"Returns the parent features for a given feature in the causal graph.\"\"\"\n    if self.ida_graph is None:\n        return []\n    return list(self.ida_graph.predecessors(feature))\n</code></pre>"},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP.get_topological_order","title":"get_topological_order","text":"<pre><code>get_topological_order(S: List[str]) -&gt; List[str]\n</code></pre> <p>Returns the topological order of variables after intervening on subset S.</p> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def get_topological_order(self, S: List[str]) -&gt; List[str]:\n    \"\"\"Returns the topological order of variables after intervening on subset S.\"\"\"\n    if self.ida_graph is None:\n        return []\n    G_intervened = self.ida_graph.copy()\n    for feature in S:\n        G_intervened.remove_edges_from(list(G_intervened.in_edges(feature)))\n    missing_nodes = set(self.data.columns) - set(G_intervened.nodes)\n    G_intervened.add_nodes_from(missing_nodes)\n\n    try:\n        order = list(nx.topological_sort(G_intervened))\n    except nx.NetworkXUnfeasible:\n        raise ValueError(\"The causal graph contains cycles.\")\n\n    return order\n</code></pre>"},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP.is_on_causal_path","title":"is_on_causal_path","text":"<pre><code>is_on_causal_path(feature: str, target_feature: str) -&gt; bool\n</code></pre> <p>Check if feature is on any causal path from S to target_feature.</p> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def is_on_causal_path(self, feature: str, target_feature: str) -&gt; bool:\n    \"\"\"Check if feature is on any causal path from S to target_feature.\"\"\"\n    if target_feature not in self.causal_paths:\n        return False\n    path_features = self.causal_paths[target_feature]\n    return feature in path_features\n</code></pre>"},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP.load_causal_strengths","title":"load_causal_strengths","text":"<pre><code>load_causal_strengths(json_file_path: str) -&gt; Dict[str, float]\n</code></pre> <p>Load causal strengths from JSON file and compute gamma values.</p> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def load_causal_strengths(self, json_file_path: str) -&gt; Dict[str, float]:\n    \"\"\"Load causal strengths from JSON file and compute gamma values.\"\"\"\n    if not isinstance(json_file_path, str):\n        raise TypeError(\"json_file_path must be a string\")\n\n    import os\n\n    if not os.path.isfile(json_file_path):\n        raise ValueError(\"json_file_path must be a valid file path\")\n\n    try:\n        with open(json_file_path, \"r\") as f:\n            causal_effects_list = json.load(f)\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid JSON file: {json_file_path}. Error: {e}\")\n\n    if not isinstance(causal_effects_list, list):\n        raise ValueError(\n            f\"JSON file must has a list, got {type(causal_effects_list).__name__}\"\n        )\n    if not causal_effects_list:\n        raise ValueError(\"JSON file contains an empty list\")\n\n    G = nx.DiGraph()\n    nodes = list(self.data.columns)\n    G.add_nodes_from(nodes)\n\n    for item in causal_effects_list:\n        pair = item[\"Pair\"]\n        mean_causal_effect = item[\"Mean_Causal_Effect\"]\n        if mean_causal_effect is None:\n            continue\n        source, target = pair.split(\"-&gt;\")\n        source = source.strip()\n        target = target.strip()\n        G.add_edge(source, target, weight=mean_causal_effect)\n    self.ida_graph = G.copy()\n\n    removed_edges = self.remove_cycles()\n    if removed_edges:\n        logger.info(\n            f\"Removed {len(removed_edges)} edges to make the graph acyclic:\"\n        )\n        for source, target, weight in removed_edges:\n            logger.info(f\"  {source} -&gt; {target} (weight: {weight})\")\n\n    self._compute_feature_depths()\n    self._compute_causal_paths()\n    features = self.data.columns.tolist()\n    beta_dict = {}\n\n    for feature in features:\n        if feature == self.target_variable:\n            continue\n        try:\n            paths = list(\n                nx.all_simple_paths(G, source=feature, target=self.target_variable)\n            )\n        except nx.NetworkXNoPath:\n            continue\n        total_effect = 0\n        for path in paths:\n            effect = 1\n            for i in range(len(path) - 1):\n                edge_weight = G[path[i]][path[i + 1]][\"weight\"]\n                effect *= edge_weight\n            total_effect += effect\n        if total_effect != 0:\n            beta_dict[feature] = total_effect\n\n    total_causal_effect = sum(abs(beta) for beta in beta_dict.values())\n    if total_causal_effect == 0:\n        self.gamma = {k: 0.0 for k in features}\n    else:\n        self.gamma = {\n            k: abs(beta_dict.get(k, 0.0)) / total_causal_effect for k in features\n        }\n    return self.gamma\n</code></pre>"},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP.remove_cycles","title":"remove_cycles","text":"<pre><code>remove_cycles() -&gt; List[Tuple[str, str, float]]\n</code></pre> <p>Detects cycles in the graph and removes edges causing cycles. Returns a list of removed edges.</p> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def remove_cycles(self) -&gt; List[Tuple[str, str, float]]:\n    \"\"\"\n    Detects cycles in the graph and removes edges causing cycles.\n    Returns a list of removed edges.\n    \"\"\"\n    if self.ida_graph is None:\n        return []\n\n    G = self.ida_graph.copy()\n    removed_edges = []\n\n    # Find all cycles in the graph\n    try:\n        cycles = list(nx.simple_cycles(G))\n    except nx.NetworkXNoCycle:\n        return []  # No cycles found\n\n    while cycles:\n        # Get the current cycle\n        cycle = cycles[0]\n\n        # Find the edge with the smallest weight in the cycle\n        min_weight = float(\"inf\")\n        edge_to_remove = None\n\n        for i in range(len(cycle)):\n            source = cycle[i]\n            target = cycle[(i + 1) % len(cycle)]\n\n            if G.has_edge(source, target):\n                weight = abs(G[source][target][\"weight\"])\n                if weight &lt; min_weight:\n                    min_weight = weight\n                    edge_to_remove = (source, target)\n\n        if edge_to_remove:\n            # Remove the edge with the smallest weight\n            G.remove_edge(*edge_to_remove)\n            removed_edges.append(\n                (\n                    edge_to_remove[0],\n                    edge_to_remove[1],\n                    self.ida_graph[edge_to_remove[0]][edge_to_remove[1]][\"weight\"],\n                )\n            )\n\n            # Recalculate cycles after removing an edge\n            try:\n                cycles = list(nx.simple_cycles(G))\n            except nx.NetworkXNoCycle:\n                cycles = []  # No more cycles\n        else:\n            break\n\n    # Update the graph\n    self.ida_graph = G\n    return removed_edges\n</code></pre>"},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP.sample_conditional","title":"sample_conditional","text":"<pre><code>sample_conditional(feature: str, parent_values: Dict[str, float]) -&gt; float\n</code></pre> <p>Sample a value for a feature conditioned on its parent features.</p> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def sample_conditional(\n    self, feature: str, parent_values: Dict[str, float]\n) -&gt; float:\n    \"\"\"Sample a value for a feature conditioned on its parent features.\"\"\"\n    effective_parents = [\n        p for p in self.get_parents(feature) if p != self.target_variable\n    ]\n    if not effective_parents:\n        return self.sample_marginal(feature)\n    model_key = (feature, tuple(sorted(effective_parents)))\n    if model_key not in self.regression_models:\n        X = self.data[effective_parents].values\n        y = self.data[feature].values\n        reg = LinearRegression()\n        reg.fit(X, y)\n        residuals = y - reg.predict(X)\n        std = residuals.std()\n        self.regression_models[model_key] = (reg, std)\n    reg, std = self.regression_models[model_key]\n    parent_values_array = np.array(\n        [parent_values[parent] for parent in effective_parents]\n    ).reshape(1, -1)\n    mean = reg.predict(parent_values_array)[0]\n    sampled_value = np.random.normal(mean, std)\n    return sampled_value\n</code></pre>"},{"location":"api-reference/#fast_causal_shap.core.FastCausalSHAP.sample_marginal","title":"sample_marginal","text":"<pre><code>sample_marginal(feature: str) -&gt; float\n</code></pre> <p>Sample a value from the marginal distribution of the specified feature.</p> Source code in <code>fast_causal_shap/core.py</code> <pre><code>def sample_marginal(self, feature: str) -&gt; float:\n    \"\"\"Sample a value from the marginal distribution of the specified feature.\"\"\"\n    return self.data[feature].sample(1).iloc[0]\n</code></pre>"}]}